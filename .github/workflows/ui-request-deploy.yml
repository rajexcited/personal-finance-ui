# Prepare process request form to deploy or destroy UI
name: Request Provisioning or Deprovisioning UI
run-name: Request - Provision or Deprovision UI

# list of trigger events https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows
on:
  issues:
    types:
      - opened

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.title }}
  cancel-in-progress: true

env:
  ARTIFACT_NAME_PREFIX: personal-finance-ui-${{ github.event.issue.milestone.title }}

permissions:
  contents: write
  id-token: write
  issues: write
  pull-requests: write

jobs:
  display_output:
    name: Display Output
    runs-on: ubuntu-latest
    steps:
      # https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
      - run: |
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue title: ${{ github.event.issue.title }}"
      - run: |
          echo "Issue body: ${{ github.event.issue.body }}"
      - env:
          MILESTONE_DTL: ${{ toJson(github.event.issue.milestone) }}
        run: |
          echo "Issue milestone title: ${{ github.event.issue.milestone.title }}"
          echo "Issue milestone: "$MILESTONE_DTL
      - run: |
          echo "Issue state: ${{ github.event.issue.state }}"
          echo "Issue state reason: ${{ github.event.issue.state_reason }}"
      - run: |
          echo "Issue draft: ${{ github.event.issue.draft }}"
          echo "Issue locked: ${{ github.event.issue.locked }}"
          echo "Issue active lock reason: ${{ github.event.issue.active_lock_reason }}"
      - run: |
          echo "Issue labels name: ${{ toJson(github.event.issue.labels.*.name) }}"
      - run: |
          echo "Issue total comments: ${{ github.event.issue.comments }}"
      - run: |
          echo "Issue updated at: ${{ github.event.issue.updated_at }}"
          echo "Issue closed at: ${{ github.event.issue.closed_at }}"
          echo "Issue created at: ${{ github.event.issue.created_at }}"
      - run: |
          echo "Issue author association: ${{ github.event.issue.author_association }}"
      - run: |
          echo "github actor: ${{ github.actor }}"
          echo "github triggering actor: ${{ github.triggering_actor }}"
          echo "Issue perfomed by app: ${{ github.event.issue.performed_via_github_app }}"
      - run: |
          echo "action: ${{ github.action }}"
          echo "event action: ${{ github.event.action }}"
          echo "event name: ${{ github.event_name }}"
          echo "event changes: ${{ github.event.changes }}"
      - env:
          GITHUB_JSON_DTL: ${{ toJson(github) }}
        run: |
          echo "github json: "$GITHUB_JSON_DTL
      - uses: actions/github-script@v7
        with:
          script: |
            console.log("Context obj: ", JSON.stringify(context));
            console.log("Github config: ", JSON.stringify(github));
            console.log("Github Rest API config: ", github.rest);
            console.log("Github Rest Issues API:", github.rest.issues);

  run_eligible:
    name: Workflow Run Eligible
    runs-on: ubuntu-latest
    outputs:
      original-issue-title: ${{ github.event.issue.title }}
      is-prod-provision: ${{ steps.request-form-issue.outputs.is-prod-provision }}
      is-testplan-provision: ${{ steps.request-form-issue.outputs.is-testplan-provision }}
      is-testplan-deprovision: ${{ steps.request-form-issue.outputs.is-testplan-deprovision }}
      is-prod-rollback: ${{ steps.request-form-issue.outputs.is-prod-rollback }}
      is-testplan: ${{ steps.request-form-issue.outputs.for-testplan }}
      is-production: ${{ steps.request-form-issue.outputs.for-production }}
      env-ref-name: ${{ steps.request-form-issue.outputs.env-ref-name }}
    steps:
      - run: |
          echo "Eligibilities"
          echo "Request form is for deployment purpose"
          echo "Request form must assigned milestone"
          echo "Request form is created by owner"
          echo "Only 1 Environment must exist"
          echo "Request form is either provision or deprovision request"
      - if: >
          ! contains(github.event.issue.labels.*.name, 'deployment') ||
          ! startsWith(github.event.issue.author_association, 'OWNER') ||
          ! github.event.issue.milestone != null
        run: |
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! contains(github.event.issue.labels.*.name, 'env: production') && 
          ! contains(github.event.issue.labels.*.name, 'env: testplan')
        run: |
          echo "environment label is not defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          contains(github.event.issue.labels.*.name, 'env: production') && 
          contains(github.event.issue.labels.*.name, 'env: testplan')
        run: |
          echo "both environment labels are defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! startsWith(github.event.issue.title, '[Request] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] [Rollback] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] Deprovision ')
        run: |
          echo "It is not Request form for provision or deprovision"
          echo Workflow is not eligible to process issue
          exit 1
      - id: request-form-issue
        name: Request Form Issue categorized
        env:
          IS_TESTPLAN: "${{ contains(github.event.issue.labels.*.name, 'env: testplan') }}"
          IS_TESTPLAN_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Test Plan Environment') }}
          IS_TESTPLAN_DEPROVISION: ${{ startsWith(github.event.issue.title, '[Request] Deprovision Test Plan Environment') }}
          IS_PRODUCTION: "${{ contains(github.event.issue.labels.*.name, 'env: production') }}"
          IS_PRODUCTION_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Production Environment') }}
          IS_PROD_ROLLBACK_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] [Rollback] Provision Production Environment') }}
        run: |
          if [[ "$IS_TESTPLAN" == "true" ]]; then
            echo "env-ref-name=testplan" >> $GITHUB_OUTPUT
          fi
          if [[ "$IS_PRODUCTION" == "true" ]]; then
            echo "env-ref-name=production" >> $GITHUB_OUTPUT
          fi
          echo "for-testplan=$IS_TESTPLAN" >> $GITHUB_OUTPUT
          echo "for-production=$IS_PRODUCTION" >> $GITHUB_OUTPUT
          echo "is-testplan-provision=$IS_TESTPLAN_PROVISION" >> $GITHUB_OUTPUT
          echo "is-testplan-deprovision=$IS_TESTPLAN_DEPROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-provision=$IS_PRODUCTION_PROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-rollback=$IS_PROD_ROLLBACK_PROVISION" >> $GITHUB_OUTPUT

  update_request:
    name: Start Request
    runs-on: ubuntu-latest
    needs:
      - run_eligible
    outputs:
      failed-reason: ${{ steps.update-request.outputs.failedReason }}
    steps:
      - id: update_issue_start
        name: Update Issue - Start Processing
        uses: actions/github-script@v7
        env:
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            try {
              const updateResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Processing] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateResponse: ", updateResponse);
              if(!context.payload.issue.locked) {
                const lockIssueResponse = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number
                });
                console.log("Lock issue response:", lockIssueResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request:
    name: Validate Request Form
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
    outputs:
      milestone-branch-name: ${{ steps.get-milestone-testplan-prov.outputs.milestoneBranchName || steps.get-milestone-prod.outputs.tagRefName }}
      milestone-branch-url: ${{ steps.get-milestone-testplan-prov.outputs.milestoneBranchUrl || steps.get-milestone-prod.outputs.tagRefUrl }}
      failed-reason: ${{ steps.testplan-request-eligible.outputs.failedReason || steps.prod-request-eligible.outputs.failedReason || steps.get-milestone-testplan-prov.outputs.failedReason || steps.get-milestone-testplan-deprov.outputs.failedReason || steps.get-milestone-prod.outputs.failedReason || steps.testplan-issue.outputs.failedReason || steps.request-form-testplan.outputs.failedReason || steps.request-form-prod.outputs.failedReason }}
      testplan-type: ${{ steps.testplan-issue.outputs.testplanType }}
      testplan-issue-number: ${{ steps.testplan-issue.outputs.testplanIssueNumber }}
      request-type: ${{ steps.get-request-type.outputs.request-type }}
      deployment-scope: ${{ steps.request-form-testplan.outputs.deployment_scope }}
      api-version: ${{ steps.request-form-testplan.outputs.api_version }}
      post-deployment-section: ${{ steps.request-form-prod.outputs.post_deployment_tasks_section }}
      pr-number: ${{ steps.branch-pr.outputs.prNumber }}
      pr-url: ${{ steps.branch-pr.outputs.prUrl }}
    steps:
      - run: |
          echo "if provision, allowed environment is either testplan or production"
          echo "if deprovision, allowed environment is testplan"
          echo "rollback is only for production environment"
          echo "if provision, milestone must be open except case of rollback"
          echo "if production, tag and milestone branch must not exist"
          echo "if rollback, milestone must be closed."
          echo "if rollback, milestone must be immediate good previous version"
          echo "if rollback, tag must exist"
      - id: testplan-request-eligible
        if: needs.run_eligible.outputs.is-testplan == 'true'
        env:
          IS_TESTPLAN_PROVISION: ${{ needs.run_eligible.outputs.is-testplan-provision }}
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          # validation relaxed for milestone if deprovision
          if [[ "$IS_TESTPLAN_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, testplan provision request. But found values, testpln provision? $IS_TESTPLAN_PROVISION, testplan deprovision? $IS_TESTPLAN_DEPROVISION"
            echo "Criteria-2, testplan environment."
            echo "Criteria-3, open milestone. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for testplan request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: prod-request-eligible
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          IS_PRODUCTION_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK_PROVISION: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          if [[ "$IS_PRODUCTION_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$IS_PROD_ROLLBACK_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "false" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, production or rollback provision request. But found values, prod provision? $IS_PRODUCTION_PROVISION, prod rollback provision? $IS_PROD_ROLLBACK_PROVISION"
            echo "Criteria-2, production environment."
            echo "Criteria-3, open milestone if production, closed milestone if rollback. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for prod request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: get-request-type
        env:
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
        run: |
          # since provision and deprovision conditions are verified appropriate to env, here we don't need to have repeatated conditions
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            echo "request-type=deprovision" >> $GITHUB_OUTPUT
          else
            echo "request-type=provision" >> $GITHUB_OUTPUT
          fi
      - id: get-milestone-testplan-prov
        if: needs.run_eligible.outputs.is-testplan-provision == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // milestone due Date must be configured and is not past.
              if(!context.payload.issue.milestone.due_on) {
                throw new Error("Milestone due date is not set");
              }
              const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
              if(milestoneDueOn < new Date()) {
                throw new Error("Milestone due date is already passed");
              }
              // verify milestone branch exists
              const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
              const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: milestoneBranch
                });
              console.log("getBranchResponse: ", getBranchResponse);
              core.setOutput("milestoneBranchName", getBranchResponse.data.name);
              core.setOutput("milestoneBranchUrl", getBranchResponse.data._links.html);
              // verify milestone branch commit has merged all of the master branch
              const compareResponse = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: "master",
                head: milestoneBranch
              });
              console.log("milestone branch as head and master branch as base, compareResponse: ", compareResponse);
              if (compareResponse.data.behind_by > 0) {
                throw new Error(`Milestone branch [${milestoneBranch}] is behind master by ${compareResponse.data.behind_by} commits.`);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: get-milestone-testplan-deprov
        if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
        name: Get Milestone Branch
        uses: actions/github-script@v7
        with:
          script: |
            // milestone due Date must be configured and is not past.
            if(!context.payload.issue.milestone.due_on) {
              const errorMessage = "Milestone due date is not set";
              console.error("failed reason: ", errorMessage);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${errorMessage}`);
              core.setFailed(errorMessage);
              throw new Error(errorMessage);
            }
      - id: testplan-issue
        if: needs.run_eligible.outputs.is-testplan == 'true'
        name: Validate Testplan issue
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
        with:
          script: |
            try {
              // currently only regression testplan is supported, so verifying if label exists.
              // Find related testplan issue and set as output for further use
              // if testplan issue is not found, then fail it
              const allowedTypes = ["regression"];
              const foundTypeLabel = context.payload.issue.labels.find(label=>allowedTypes.includes(label.name));
              if(!foundTypeLabel) {
                throw new Error("Test plan type label not found in issue labels");
              }
              core.setOutput("testplanType", foundTypeLabel.name);
              // find test plan issue with same milestone and type label
              const testplanIssueRegex = new RegExp(".+Test Plan:.+https://github.com/"+context.repo.owner+"/"+context.repo.repo+"/issues/(\\d+).+", "i");
              if(!testplanIssueRegex.test(context.payload.issue.body)) {
                throw new Error("Test plan issue link not found")
              }
              const testplanIssueNumber = testplanIssueRegex.exec(context.payload.issue.body)[1];
              const getIssueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: testplanIssueNumber
              });
              console.log("getIssueResponse: ", getIssueResponse);
              const allowedLabels = [foundTypeLabel.name, "env: testplan"];
              const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
              if(testplanLabels.length!==allowedLabels.length){
                throw new Error("missing required labels in given testplan issue");
              }
              if(getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number){
                throw new Error("assigned milestone to given testplan issue is not same with this issue");
              }
              // validation relaxed - testplan issue can be open or closed for deprovisioning
              if(process.env.TESTPLAN_REQUEST_TYPE === "provision" && getIssueResponse.data.state!=="open"){
                throw new Error("testplan issue not open");
              }
              core.setOutput("testplanIssue", getIssueResponse.data);
              core.setOutput("testplanIssueNumber", getIssueResponse.data.number);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: get-milestone-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        env:
          IS_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const getBranch = async (branchName, tagName) => {
                try {
                  if(branchName) {
                    const getBranchResponse = await github.rest.repos.getBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      branch: branchName
                    });
                    console.log("getBranchResponse: ", getBranchResponse);
                    return getBranchResponse.data;
                  }
                  if(tagName) {
                    const getRefResponse = await github.rest.git.getRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tagName}`
                    });
                    console.log("getRefResponse: ", getRefResponse);
                    return getRefResponse.data;
                  }
                  throw new Error("requested neither branch nor tag");
                } catch(e) {
                  console.error("error during getBranch rest call", e);
                }
                return null;
              };
              // milestone due Date must be configured and is not past.
              if(!context.payload.issue.milestone.due_on) {
                throw new Error("Milestone due date is not set");
              }
              if(process.env.IS_ROLLBACK != "true") {
                // for prod deployment, date has to be today
                const milestoneDueOnDate = toTime(context.payload.issue.milestone.due_on).substring(0,10);
                if(milestoneDueOnDate !== toTime(new Date()).substring(0,10)) {
                  throw new Error("Milestone due date is not today");
                }
                // verify milestone branch not exists
                const milestoneBranch = await getBranch(`milestone/${context.payload.issue.milestone.title}`);
                if(milestoneBranch) {
                  throw new Error("milestone branch exist. It has to be merge to master and delete before prod deployment");
                }
              }
              // verify tag ref
              const tagRef = await getBranch(null, context.payload.issue.milestone.title);
              if(tagRef && process.env.IS_ROLLBACK != "true") {
                throw new Error(`for production deploy, tag [${context.payload.issue.milestone.title}] cannot exist.`);
              }
              if(!tagRef && process.env.IS_ROLLBACK == "true") {
                throw new Error(`for production rollback deploy, tag [${context.payload.issue.milestone.title}] not found.`);
              }
              if(tagRef) {
                core.setOutput("tagRefName", tagRef.ref);
                core.setOutput("tagRefUrl", `${context.payload.repository.html_url}/tree/${tagRef.ref.split("/").splice(-1)[0]}`);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          cache: "pip" # caching pip dependencies
          python-version: "3.13"
      - id: request-issue
        uses: actions/github-script@v7
        with:
          script: |
            core.setOutput("issueDetails", context.payload.issue);
      - id: request-form-testplan
        if: needs.run_eligible.outputs.is-testplan == 'true'
        name: Validate Request Form Details
        env:
          TESTPLAN_TYPE: ${{ steps.testplan-issue.outputs.testplanType }}
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
          TESTPLAN_ISSUE_DETAILS: ${{ steps.testplan-issue.outputs.testplanIssue }}
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
        run: |
          cd .github
          echo "storing details to json files"
          echo $TESTPLAN_ISSUE_DETAILS > parent_issue_details.json
          echo $ISSUE_DETAILS > request_form_issue_details.json
          ls -lrt
          echo $(date)
          python --version
          pip install -r scripts/requirements.txt
          # capture error code +-e
          set +e
          python -m scripts.request.deploy.testplan --validate \
              --parent-issue-details "parent_issue_details.json" \
              --request-form-issue-details "request_form_issue_details.json" \
              --request-type $TESTPLAN_REQUEST_TYPE \
              --testplan-type "$TESTPLAN_TYPE" > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: request-form-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Request Form Details
        env:
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          python --version
          pip install -r scripts/requirements.txt
          set +e
          python -m scripts.request.deploy.production --validate \
              --request-form-issue-details "request_form_issue_details.json"  > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - name: Validate Rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        uses: actions/github-script@v7
        env:
          EXISTING_VERSION: ${{ steps.request-form-prod.outputs.existing_version }}
        with:
          script: |
            try {
              // tag is already verified
              // here, verify rollback milestone is closed
              // verify released approved issue exists
              // relaxed other validations

              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              // find related issue of release form
              // verify rollback version is immediate valid previous version, milestone and tag
              const listMilestonesResponse = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "closed"
              });
              console.log("listMilestonesResponse: ", listMilestonesResponse);
              const deployedMilestone=listMilestonesResponse.data.find(mlst=>mlst.title===process.env.EXISTING_VERSION);
              if(!deployedMilestone) {
                throw new Error("deployed milestone is not found");
              }
              // verify approved prod release issue exists
              const listIssuesResponse = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ["deployment", "env: production"],
                state: "closed",
                milestone: deployedMilestone.number
              });
              console.log("listIssuesResponse: ", listIssuesResponse);
              const releasedRequest = listIssuesResponse.data.find(iss=>iss.title.startsWith("[Approved] [Request] Provision Production Environment"));
              if(!releasedRequest) {
                throw new Error("prod release request form not found");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during rollback validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: branch-pr
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.get-milestone-testplan-prov.outputs.milestoneBranchName }}
        with:
          script: |
            try {
              const openPRListResponse = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: "master",
                head: process.env.BRANCH_NAME
              });
              console.log("openPRListResponse: ", openPRListResponse);
              const foundPr = openPRListResponse.data.find(pr=>pr.milestone.number===context.payload.issue.milestone.number)
              core.setOutput("prNumber", foundPr?.number);
              core.setOutput("prUrl", foundPr?.html_url);
            } catch(ignore) {
            }

  validate_stack:
    name: Validate Stacks
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
    environment:
      name: ${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.provision-stack-testplan.outputs.failedReason || steps.deprovision-stack-testplan.outputs.failedReason || steps.provision-stack-prod.outputs.failedReason || steps.provision-stack-prod-rollback.outputs.failedReason }}
      stack-details: ${{ steps.provision-stack-testplan.outputs.stack_details || steps.deprovision-stack-testplan.outputs.stack_details || steps.provision-stack-prod.outputs.stack_details || steps.provision-stack-prod-rollback.outputs.stack_details || '{}' }}
      api-stack-status: ${{ steps.provision-stack-testplan.outputs.api_stack_status || steps.deprovision-stack-testplan.outputs.api_stack_status || steps.provision-stack-prod.outputs.api_stack_status || steps.provision-stack-prod-rollback.outputs.api_stack_status }}
      ui-stack-status: ${{ steps.provision-stack-testplan.outputs.ui_stack_status || steps.deprovision-stack-testplan.outputs.ui_stack_status || steps.provision-stack-prod.outputs.ui_stack_status || steps.provision-stack-prod-rollback.outputs.ui_stack_status }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: provision-stack-testplan
        if: needs.run_eligible.outputs.is-testplan-provision == 'true'
        name: Verify milestone branch is deployable
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          API_VERSION: ${{ needs.validate_request.outputs.api-version }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISS_REPO: ${{ github.event.repository.name }}
          TESTPLAN_ISS_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          UI_STACK_NAME="prsfin-$ENVID-ui-deploy-stack"  
          set +e
          DESCRIBE_UI_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$UI_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "UI Stack does not exist. milestone branch can be deployed."
            exit 0
          fi

          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          echo "ui_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$ENVID" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Type 
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type doesnot match. Found $TAG_VALUE testplan type."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Issue number 
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanIssueNumber").Value')
          EXPECTED_TESTPLAN_ISS="$TESTPLAN_ISS_REPO/issue-$TESTPLAN_ISS_NUMBER"
          if [[ "$TAG_VALUE" != "$EXPECTED_TESTPLAN_ISS" ]]; then
            FAILED_REASON="The stack is deployed for another testplan issue, $TAG_VALUE, instead of $EXPECTED_TESTPLAN_ISS."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          UI_CREATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          UI_UPDATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          UI_STACK_AUDIT='{"created_time":"'$UI_CREATED_TIME'","updated_time":"'$UI_UPDATED_TIME'"}'

          if [[ -z "$API_VERSION" ]]; then
            echo "Api version is not provided. Will not deploy api stack."
            API_STACK_AUDIT='{}'
          else
            echo "Found UI stack and API version is provided. Proceeding with API stack validation."
            API_STACK_NAME="prsfin-$ENVID-infra-stack"
            set +e
            DESCRIBE_API_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$API_STACK_NAME")
            RET_CODE=$?
            set -e

            if [[ $RET_CODE -ne 0 ]]; then
              FAILED_REASON="Unable to describe API stack. It should exist. Unknown error"
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi

            # verify stack status
            STACK_STATUS=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            echo "api_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
            if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
              STACK_STATUS_REASON=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
              FAILED_REASON="The Stack status is not complete status, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
            # environment tag match must never fail
            TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
            if [[ "$TAG_VALUE" != "$ENVID" ]]; then
              FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
            # check milestone 
            TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
            if [[ "$TAG_VALUE" != "$API_VERSION" ]]; then
              FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
            # check testplan Type 
            TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
            if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
              FAILED_REASON="The testplan type doesnot match. Found $TAG_VALUE testplan type."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
            # check testplan Issue number 
            TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanIssueNumber").Value')
            EXPECTED_TESTPLAN_ISS="$TESTPLAN_ISS_REPO/issue-$TESTPLAN_ISS_NUMBER"
            if [[ "$TAG_VALUE" != "$EXPECTED_TESTPLAN_ISS" ]]; then
              FAILED_REASON="The stack is deployed for another testplan issue, $TAG_VALUE, instead of $EXPECTED_TESTPLAN_ISS."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi

            API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
            API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
            API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          fi

          STACK_AUDIT='{"ui":'$UI_STACK_AUDIT',"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-prod
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        name: Verify Stack for Prod Release
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          UI_STACK_NAME="prsfin-$ENVID-ui-deploy-stack"  
          set +e
          DESCRIBE_UI_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$UI_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "UI Stack does not exist. milestone branch can be deployed."
            exit 0
          fi

          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          echo "ui_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$ENVID" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          UI_CREATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          UI_UPDATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          UI_STACK_AUDIT='{"created_time":"'$UI_CREATED_TIME'","updated_time":"'$UI_UPDATED_TIME'"}'

          STACK_AUDIT='{"ui":'$UI_STACK_AUDIT',"api":{}}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          STACK_NAME="prsfin-$ENVID-infra-stack"
          DESCRIBE_API_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")

          STACK_STATUS=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].StackStatus")
          echo "api_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
      - id: provision-stack-prod-rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        name: Verify Stack for Prod Rollback
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
          ROLLBACK_MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          UI_STACK_NAME="prsfin-$ENVID-ui-deploy-stack"  
          set +e
          DESCRIBE_UI_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$UI_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "UI Stack does not exist. milestone branch can be deployed."
            exit 0
          fi

          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          echo "ui_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$ENVID" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" == "$ROLLBACK_MILESTONE_TITLE" ]]; then
            FAILED_REASON="There was already rollback deployment attempt. Another attempt is not possible"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          UI_CREATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          UI_UPDATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          UI_STACK_AUDIT='{"created_time":"'$UI_CREATED_TIME'","updated_time":"'$UI_UPDATED_TIME'"}'

          STACK_AUDIT='{"ui":'$UI_STACK_AUDIT',"api":{}}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          STACK_NAME="prsfin-$ENVID-infra-stack"
          DESCRIBE_API_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")

          STACK_STATUS=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].StackStatus")
          echo "api_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
      - id: deprovision-stack-testplan
        if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
        name: Verify milestone branch is destroyable
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          UI_VERSION: ${{ github.event.issue.milestone.title }}
          API_VERSION: ${{ needs.validate_request.outputs.api-version }}
        run: |
          STACK_NAME="prsfin-$ENVID-ui-deploy-stack"  
          set +e
          DESCRIBE_UI_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="UI Stack does not exist. milestone branch has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          STACK_STATUS=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].StackStatus")
          echo "ui_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT

          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$ENVID" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$UI_VERSION" ]]; then
            FAILED_REASON="Other milestone branch is deployed to UI Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          CREATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          UPDATED_TIME=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          UI_STACK_AUDIT='{"created_time":'$CREATED_TIME',"updated_time":'$UPDATED_TIME'}'

          STACK_NAME="prsfin-$ENVID-infra-stack"
          DESCRIBE_API_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")

          STACK_STATUS=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].StackStatus")
          echo "api_stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT

          TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$ENVID" ]]; then
            FAILED_REASON="API Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$API_VERSION" ]]; then
            FAILED_REASON="Other milestone branch is deployed to API Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":'$CREATED_TIME',"updated_time":'$UPDATED_TIME'}'

          STACK_AUDIT='{"ui":'$UI_STACK_AUDIT',"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  validate_request_api:
    name: Validate Request form phase2 (API)
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
    environment: static-site
    outputs:
      api-milestone-number: ${{ steps.api-milestone-testplan.outputs.apiMilestoneNumber }}
      failed-reason: ${{ steps.api-milestone-testplan.outputs.failedReason }}
    steps:
      - id: api-milestone-testplan
        name: Validate API Milestone
        if: >
          contains(needs.validate_request.outputs.deployment-scope, 'api') &&
          needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          BACKEND_REPO_NAME: ${{ vars.UI_DEPLOY_REPO_NAME }}
          API_VERSION: ${{ needs.validate_request.outputs.api-version }}
        with:
          github-token: ${{ secrets.ON_DEMAND_DEPLOY_UI_PAT }}
          script: |
            try {
              const listMilestonesResponse = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: process.env.BACKEND_REPO_NAME,
                state: "all"
              });
              console.log("listMilestonesResponse: ", listMilestonesResponse);
              const apiMilestone = listMilestonesResponse.data.find(mlstn=>mlstn.title===process.env.API_VERSION);
              if(!apiMilestone) {
                throw new Error(`Milestone issue is not found. provided version[${process.env.API_VERSION}] incorrect.`);
              }
              console.log("found matching version milestone", apiMilestone)
              core.setOutput("apiMilestoneNumber", apiMilestone.number);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - run: |
          echo "api-milestone: ${{ steps.api-milestone-testplan.outputs.apiMilestoneNumber }}"
          echo "failed-reason: ${{ steps.api-milestone-testplan.outputs.failedReason }}"

  create_tag:
    name: Create Tag
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_stack
      - validate_request_api
    if: needs.validate_request.outputs.request-type == 'provision'
    outputs:
      failed-reason: ${{ steps.no-branch.outputs.failedReason || steps.create-prod-tag.outputs.failedReason }}
      branch-tag-name: ${{ needs.validate_request.outputs.milestone-branch-name || github.event.issue.milestone.title }}
    steps:
      - id: no-branch
        env:
          BRANCH_NAME: ${{ needs.validate_request.outputs.milestone-branch-name }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_PROD_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
        run: |
          if [[ -z "$BRANCH_NAME" ]]; then
            if [[ "$IS_PROD_ROLLBACK" == "true" ]]; then
              FAILED_REASON="Tag for prod rollback is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
            if [[ "$IS_TESTPLAN" == "true" ]]; then
              FAILED_REASON="Milestone Branch is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
          elif [[ "$IS_PROD_PROVISION" == "true" ]]; then
            FAILED_REASON="Tag cannot be available for prod."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "$FAILED_REASON"
            exit 1
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: create-prod-tag
        name: Create Tag
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        env:
          TAG_VER: ${{ github.event.issue.milestone.title }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          LOG_FILE="create_tag.failed.log"
          if ! git tag -a "$TAG_VER" -m "Release $TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to create tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          if ! git push origin "$TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to push tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi

  build_artifact:
    name: create artifact
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - create_tag
    environment: static-site
    outputs:
      artifact-name: ${{ steps.run-build.outputs.artifact-name }}
      artifact-id: ${{ steps.upload-artifact.outputs.artifact-id }}
      artifact-url: ${{ steps.upload-artifact.outputs.artifact-url }}
      artifact-digest: ${{ steps.upload-artifact.outputs.artifact-digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        # https://github.com/actions/setup-node
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - id: run-build
        name: Build Code
        run: |
          npm --version
          npm ci
          cp src/demo/dummy.ts src/demo/index.ts
          npm run build
          echo "artifact-name=$ARTIFACT_NAME_PREFIX-$ENV_REF_NAME" >> $GITHUB_OUTPUT
        env:
          REACT_APP_BASE_PATH: ${{ vars.REACT_APP_BASE_PATH }}
          REACT_APP_REST_API_BASE_PATH: ${{ vars.REACT_APP_REST_API_BASE_PATH }}
          REACT_APP_MINIMUM_SESSION_TIME: ${{ vars.REACT_APP_MINIMUM_SESSION_TIME }}
          GENERATE_SOURCEMAP: ${{ needs.run_eligible.outputs.is-testplan == 'true' }}
          PUBLIC_URL: ${{ vars.PUBLIC_URL }}
          ARTIFACT_NAME_PREFIX: ${{ env.ARTIFACT_NAME_PREFIX }}
          ENV_REF_NAME: ${{ needs.run_eligible.outputs.env-ref-name }}
      - name: upload artifact
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.run-build.outputs.artifact-name }}
          path: ./build/
          if-no-files-found: error
          retention-days: 2
          overwrite: true
      - name: artifact Outputs
        run: |
          echo Artifact Name is ${{ steps.run-build.outputs.artifact-name }}
          echo Artifact ID is ${{ steps.upload-artifact.outputs.artifact-id }}
          echo Artifact URL is ${{ steps.upload-artifact.outputs.artifact-url }}
          echo Artifact DIGEST is ${{ steps.upload-artifact.outputs.artifact-digest }}

  deployment:
    name: deploy static UI
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_stack
      - validate_request_api
      - build_artifact
    environment: static-site
    outputs:
      deployment-start-time: ${{ steps.dispatch-payload.outputs.deploymentStartTime }}
      ui-stack-tags: ${{ steps.dispatch-payload.outputs.uiStackTags }}
      failed-reason: ${{ steps.create-api-issue.outputs.failedReason || steps.dispatch-payload.outputs.failedReason || steps.update-issue-deploying.outputs.failedReason }}
      is-deploying-api-stack: ${{ steps.create-api-issue.outputs.isDeployingApiStack }}
    steps:
      - run: |
          echo "API Milestone number: ${{ needs.validate_request_api.outputs.api-milestone-number }}"
          echo "Deployment Scope: ${{ needs.validate_request.outputs.deployment-scope }}"
          echo "Stack details: ${{ toJson(needs.validate_stack.outputs.stack-details) }}"
      - id: create-api-issue
        name: Provision API Environment
        uses: actions/github-script@v7
        if: >
          contains(needs.validate_request.outputs.deployment-scope, 'api') &&
          needs.run_eligible.outputs.is-testplan == 'true'
        env:
          BACKEND_REPO_NAME: ${{ vars.UI_DEPLOY_REPO_NAME }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          API_MILESTONE_NUMBER: ${{ needs.validate_request_api.outputs.api-milestone-number }}
        with:
          github-token: ${{ secrets.ON_DEMAND_DEPLOY_UI_PAT }}
          script: |
            try {
              console.log("API_MILESTONE_NUMBER: ",process.env.API_MILESTONE_NUMBER);
              let issueBody = context.payload.issue.body;
              issueBody += "\n\n";
              issueBody += "Created because of UI Provision Issue "
              issueBody += `[Issue-${context.payload.issue.number}](${context.payload.issue.html_url})`;
              issueBody += "\n\n";
              const createIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: process.env.BACKEND_REPO_NAME,
                title: process.env.ORIGINAL_ISSUE_TITLE,
                body: issueBody,
                labels: ["deployment", "env: testplan", process.env.TESTPLAN_TYPE],
                milestone: process.env.API_MILESTONE_NUMBER
              });
              console.log("api createIssueResponse: ", createIssueResponse);
              core.setOutput("details", createIssueResponse.data);
              core.setOutput("isDeployingApiStack", "true");
              /* add parent testplan issue as parent relationship to api issue
               when github rest and octokit will add support cross repo issue relationship */
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during API issue creation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: dispatch-payload
        name: Prepare Dispatch Payload
        uses: actions/github-script@v7
        env:
          EVENT_TYPE: ${{ vars.UI_DEPLOY_EVENT_TYPE }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          API_VERSION: ${{ needs.validate_request.outputs.api-version }}
          STACK_REPO_NAME: ${{ vars.UI_DEPLOY_REPO_NAME }}
          ARTIFACT_NAME: ${{ needs.build_artifact.outputs.artifact-name }}
          ENV_TYPE: ${{ needs.run_eligible.outputs.env-ref-name }}
          IS_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          IS_PRODUCTION: ${{ needs.run_eligible.outputs.is-production }}
          INITIAL_API_STACK_STATUS: ${{ needs.validate_stack.outputs.api-stack-status }}
          IS_API_STACK_DEPLOYING: ${{ steps.create-api-issue.outputs.isDeployingApiStack }}
        with:
          github-token: ${{ secrets.ON_DEMAND_DEPLOY_UI_PAT }}
          script: |
            try {
              const clientPayload = {
                env: {
                  env_type: process.env.ENV_TYPE,
                  is_testplan: process.env.IS_TESTPLAN,
                  is_prod: process.env.IS_PRODUCTION
                },
                artifact: {
                  name: process.env.ARTIFACT_NAME,
                  ui_repository: context.repo.owner + "/" + context.repo.repo,
                  workflow_run_id: context.runId
                },
                type: "provision",
                milestone: context.payload.issue.milestone.title,
                stack_tags: [],
                infraStack: {
                  isDeploying: String(process.env.IS_API_STACK_DEPLOYING === "true"),
                  initialStatus: process.env.INITIAL_API_STACK_STATUS
                }
              };
              clientPayload.stack_tags.push(`workflow_run_id=${context.runId}`);
              clientPayload.stack_tags.push(`milestone=${context.payload.issue.milestone.title}`);
              clientPayload.stack_tags.push(`requestIssueNumber=${context.repo.repo}/issue-${context.payload.issue.number}`);
              if(process.env.TESTPLAN_TYPE && process.env.TESTPLAN_ISSUE_NUMBER) {
                clientPayload.stack_tags.push(`testplanType=${process.env.TESTPLAN_TYPE}`);
                clientPayload.stack_tags.push(`testplanIssueNumber=${context.repo.repo}/issue-${process.env.TESTPLAN_ISSUE_NUMBER}`);
              }
              const apiVersion = process.env.API_VERSION
              if(apiVersion) {
                clientPayload.stack_tags.push(`apiVersion=${apiVersion}`);
                clientPayload.apiVersion = apiVersion;
              }
              console.log(`submitting event [${process.env.EVENT_TYPE}] with Client Payload:`, clientPayload);
              const createDispatchEventResponse = await github.rest.repos.createDispatchEvent({
                owner:context.repo.owner,
                repo: process.env.STACK_REPO_NAME,
                event_type: process.env.EVENT_TYPE,
                client_payload: clientPayload
              });
              console.log("createDispatchEventResponse: ", createDispatchEventResponse);
              core.setOutput("deploymentStartTime", new Date().toISOString());
              core.setOutput("uiStackTags", clientPayload.stack_tags);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during dispatch payload creation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: update-issue-deploying
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          ARTIFACT_URL: ${{ needs.build_artifact.outputs.artifact-url }}
          ARTIFACT_ID: ${{ needs.build_artifact.outputs.artifact-id }}
          ARTIFACT_NAME: ${{ needs.build_artifact.outputs.artifact-name }}
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.milestone-branch-name || github.event.issue.milestone.title }}
          IS_FOR_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          IS_PROD_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          DEPLOY_START_TIME: ${{ steps.dispatch-payload.outputs.deploymentStartTime }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              let prodType="";
              if(process.env.IS_PROD_RELEASE == "true") {
                prodType="Release "
              }
              if(process.env.IS_PROD_ROLLBACK == "true") {
                prodType="Rollback "
              }
              const artifactTitleWithLink = `[${process.env.ARTIFACT_NAME} (${process.env.ARTIFACT_ID})](${process.env.ARTIFACT_URL})`;
              const commentBody = [
                `## UI ${prodType}Deployment Started`,
                "<br/>", 
                "", "### Start Time: ", "",
                "  " + toTime(process.env.DEPLOY_START_TIME), 
              ];
              if("true" == process.env.IS_FOR_TESTPLAN) {
                commentBody.push("", "### Milestone Branch: ", "");
              } else {
                commentBody.push("", "### Tag: ", "");
              }
              commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);
              commentBody.push("", "### UI Artifact: ", "");
              commentBody.push("  The artifact is created and passed to deployment. You can verify artifact by downloading, " + artifactTitleWithLink);
              
              commentBody.push("", "### UI Stack: ", "");
              const stackDetails = ${{ needs.validate_stack.outputs.stack-details }};
              if(stackDetails?.ui?.created_time && stackDetails?.ui?.updated_time) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.ui.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.ui.updated_time));
              } else {
                commentBody.push("UI Stack is not found. It seems to be first deployment.");
              }

              commentBody.push("", "### API Stack: ", "");
              const apiIssueDetails = ${{ steps.create-api-issue.outputs.details || '{}' }};
              if(apiIssueDetails?.number) {
                const apiIssueWithLink = "[API Issue-" + apiIssueDetails.number + "](" + apiIssueDetails.html_url + ")";
                commentBody.push("The " + apiIssueWithLink + ", for API deployment is created.", "");
              }
              if(stackDetails?.api?.created_time && stackDetails?.api?.updated_time) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              } else {
                commentBody.push("API Stack is not found. It seems to be first deployment.");
              }
              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the deployment to complete. This issue will be updated with deployment status.");
              commentBody.push("<br/>", "<br/>",  "");
              
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  deployment_complete:
    name: Handle Deployment Completion
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_stack
      - deployment
    environment:
      name: ${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.wait-for-ui-deployment.outputs.failedReason || steps.update-issue-deployment-complete.outputs.failedReason || steps.post-deployment-verification-issue.outputs.failedReason }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: Setup Node Latest
        # https://github.com/actions/setup-node
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - run: |
          npm install @aws-sdk/client-cloudformation
      - id: wait-for-ui-deployment
        name: Wait for UI Deployment to Complete
        uses: actions/github-script@v7
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          DEPLOYMENT_SCOPE: ${{ needs.validate_request.outputs.deployment-scope }}
          INITIAL_UI_STACK_STATUS: ${{ needs.validate_stack.outputs.ui-stack-status }}
          INITIAL_API_STACK_STATUS: ${{ needs.validate_stack.outputs.api-stack-status }}
          IS_DEPLOYING_API_STACK: ${{ needs.deployment.outputs.is-deploying-api-stack }}
        with:
          script: |
            try {
              const { CloudFormationClient, DescribeStacksCommand } = require("@aws-sdk/client-cloudformation");
              const ONE_SECOND = 1000;
              const ONE_MINUTE = ONE_SECOND * 60;
              const sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
              // Initialize CloudFormation client
              // https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/cloudformation/command/DescribeStacksCommand/
              const cloudFormationClient = new CloudFormationClient();
              const describeStack = async (stackName) => {
                try {
                  const command = new DescribeStacksCommand({ StackName: stackName });
                  const response = await cloudFormationClient.send(command);
                  console.log("method describeStack, response:", response);
                  return response.Stacks[0];
                } catch(e) {
                  console.error("method describeStack, got an error: ", e);
                }
                return null;
              };
              const stackSuccessRegex = new RegExp("CREATE_COMPLETE|UPDATE_COMPLETE");
              const stackFailRegex = new RegExp("CREATE_FAILED|UPDATE_FAILED|ROLLBACK*|UPDATE_ROLLBACK*|DELETE*");

              const sleepDuration = ONE_MINUTE;
              const totalWaitDuration = 60 * ONE_MINUTE;
              let waitedDuration = 0;
              let describeStackResponse = null;
              const uiStackName = `prsfin-${process.env.ENVID}-ui-deploy-stack`;
              const apiStackName = `prsfin-${process.env.ENVID}-infra-stack`;
              let isApiStackDeployed = process.env.IS_DEPLOYING_API_STACK !== "true";
              let isStackStatusChanged = false;
              let maxWaitForStatusUnchange = sleepDuration * 10;
              
              while(waitedDuration < totalWaitDuration) {
                console.log("Deployment is in progress.", `Waiting for ${sleepDuration/ONE_SECOND} seconds ~ ${sleepDuration/ONE_MINUTE} minutes.`);
                console.log(`waited ${waitedDuration/ONE_MINUTE} minutes for deployment complete out of allowed ${totalWaitDuration/ONE_MINUTE} minutes`);
                await sleep(sleepDuration);
                waitedDuration += sleepDuration;
                
                const stackName = isApiStackDeployed? uiStackName: apiStackName;
                describeStackResponse = await describeStack(stackName);
                let continueWaiting=false;
                if(!describeStackResponse) {
                  continueWaiting=true;
                }
                if(!continueWaiting && !isApiStackDeployed && process.env.INITIAL_API_STACK_STATUS===describeStackResponse?.StackStatus && !isStackStatusChanged) {
                  continueWaiting=true;
                }
                if(!continueWaiting && isApiStackDeployed && process.env.INITIAL_UI_STACK_STATUS===describeStackResponse?.StackStatus && !isStackStatusChanged) {
                  continueWaiting=true;
                }
                if(continueWaiting) {
                  // since no response, probably still in creation not started
                  if(waitedDuration<maxWaitForStatusUnchange) {
                    continue;
                  }
                  throw new Error("Stack status hasnt been changed.");
                }
                isStackStatusChanged=true;
                if(stackSuccessRegex.test(describeStackResponse.StackStatus)) {
                  if(isApiStackDeployed) {
                    console.log("UI Stack is deployed successfully.")
                    break;
                  }
                  isApiStackDeployed=true;
                  isStackStatusChanged=false;
                  // to give same wait time for UI stack initialization
                  maxWaitForStatusUnchange += waitedDuration;
                  console.log("API Stack is deployed successfully.")
                  continue;
                }
                if(stackFailRegex.test(describeStackResponse.StackStatus)) {
                  throw new Error(`UI Stack deployment failed. found undesired Status [${describeStackResponse.StackStatus}] with reason, ${describeStackResponse.StackStatusReason}. Please check stack events for more details.`);
                }
              }

              if(!describeStackResponse) {
                throw new Error(`UI Stack deployment is taking longer time than expected(${totalWaitDuration/ONE_MINUTE} minutes). Please check the status manually.`)
              }
              
              core.setOutput("uiDescribeStack", describeStackResponse);
              const convertedTagList = describeStackResponse.Tags.map(st=>`${st.Key}=${st.Value}`);
              describeStackResponse = await describeStack(`prsfin-${process.env.ENVID}-infra-stack`);
              
              const stackTags = ${{ needs.deployment.outputs.ui-stack-tags }};
              const unMatchTagList = stackTags.filter(st=> !convertedTagList.includes(st));
              if(unMatchTagList.length > 0) {
                if(unMatchTagList.length === stackTags.length) {
                  if(!describeStackResponse) {
                    throw new Error("UI Deployment is not started, because Api Stack is not found.");
                  }
                  if(stackSuccessRegex.test(describeStackResponse.StackStatus)) {
                    throw new Error("UI Deployment is not started, because API stack failed");
                  }
                  throw new Error("UI Deployment is not started");
                }
                throw new Error(`Found some tags not matching. mismatch Tags: ${unMatchTagList}`);
              }
              const stackAudit = {ui:{}, api:{}};
              stackAudit.ui.created_time=describeStackResponse.CreationTime.toISOString();
              stackAudit.ui.updated_time=describeStackResponse.LastUpdatedTime.toISOString();
              
              if(process.env.DEPLOYMENT_SCOPE.includes("api")) {
                if(!describeStackResponse) {
                  throw new Error("Api Stack deployment is not found.");
                }
                if(stackFailRegex.test(describeStackResponse.StackStatus)) {
                  throw new Error("Api Stack deployment is failed.")
                }
                stackAudit.api.created_time=describeStackResponse.CreationTime.toISOString();
                stackAudit.api.updated_time=describeStackResponse.LastUpdatedTime.toISOString();
              }

              core.setOutput("apiDescribeStack", describeStackResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error deployment wait step, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: update-issue-deployment-complete
        name: Update Issue - Deployment Complete
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_START_TIME: ${{ needs.deployment.outputs.deployment-start-time }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          DEPLOYMENT_SCOPE: ${{ needs.validate_request.outputs.deployment-scope }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
        with:
          script: |
            try {
              const deploymentEndTime = new Date();
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const diffParts = new Date(deploymentEndTime - new Date(process.env.DEPLOYMENT_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              const commentBody = [
                "## UI Deployment Completed",
                "<br/>", 
                "", "### Deployment Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DEPLOYMENT_START_TIME)} |`,
                `| **End Time** | ${toTime(deploymentEndTime)} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];
              
              const uiDescribeStack = ${{ steps.wait-for-ui-deployment.outputs.uiDescribeStack }};
              const apiDescribeStack = ${{ steps.wait-for-ui-deployment.outputs.apiDescribeStack }};
              const domainUrlOutput = apiDescribeStack.Outputs?.find(output => output.OutputKey.startsWith("DistributionDomain"))?.OutputValue;
              if(domainUrlOutput) {
                commentBody.push("", "### Domain UI URL: ", "");
                commentBody.push("  https://" + domainUrlOutput);
              }
              
              commentBody.push("", "### UI Stack: ", "");
              // audit details available
              commentBody.push("- **Created On:**  " + toTime(uiDescribeStack.CreationTime));
              commentBody.push("- **Updated On:**  " + toTime(uiDescribeStack.LastUpdatedTime));
              
              commentBody.push("", "#### Stack Outputs: ", "");
              if(!uiDescribeStack.Outputs || uiDescribeStack.Outputs.length === 0) {
                commentBody.push("  No outputs found.  ");
              } else {
                uiDescribeStack.Outputs.forEach(output => {
                  commentBody.push(` - **${output.OutputKey}:** ${output.OutputValue}  `);
                });
              }
              
              commentBody.push("", "#### Stack Tags: ", "");
              uiDescribeStack.Tags.forEach(tag=>{
                commentBody.push(`- **${tag.Key}:** ${tag.Value}  `);
              });
              
              if(process.env.DEPLOYMENT_SCOPE.includes("api")) {
                commentBody.push("", "### API Stack: ", "");
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              }
              
              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The Deployment is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");
              
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              if(process.env.TESTPLAN_ISSUE_NUMBER) {
                const unlockIssueResponse2 = await github.rest.issues.unlock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.TESTPLAN_ISSUE_NUMBER
                });
                console.log("testplan issue is unlock temporarily, unlock issue response:", unlockIssueResponse2);
                const parentCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.TESTPLAN_ISSUE_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for testplan, commentResponse: ", parentCommentResponse);
                const lockIssueResponse2 = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.TESTPLAN_ISSUE_NUMBER
                });
                console.log("issue is lock again, lock issue response:", lockIssueResponse2);
              }
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for deployment completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: post-deployment-verification-issue
        name: Post Deployment Verification Issue
        uses: actions/github-script@v7
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          POST_DEPLOY_REQ_SECTION: ${{ needs.validate_request.outputs.post-deployment-section }}
          IS_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
        with:
          script: |
            try {
              let deploymentType = "Release";
              if(process.env.IS_RELEASE != "true") {
                deploymentType = "Rollback";
              }
              let issueBody = "\n## Deployment Completed\n\n";
              issueBody += `### Parent ${deploymentType} Deployment\n\n`;
              issueBody += `- Request [Issue-${context.payload.issue.number}](${context.payload.issue.html_url})\n\n`;
              issueBody += process.env.POST_DEPLOY_REQ_SECTION;
              issueBody += "\n\n  ";
              issueBody += "> [!IMPORTANT]  \n";
              issueBody += "> Please checked tasks if verified successfully. When post deployment verification is completed, close the issue regardless the status to mark the deployment attempt complete.  ";
              const createIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: "[Task] Post Deployment Verifications for Prod " + deploymentType,
                body: issueBody,
                labels: context.payload.issue.labels.map(label=>label.name),
                milestone: context.payload.issue.milestone.number
              });
              console.log("api createIssueResponse: ", createIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: createIssueResponse.data.number
              });
              console.log("lock issue response:", lockIssueResponse);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for deployment completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy:
    name: Destroy UI Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_api
      - validate_stack
    if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
    environment: static-site
    outputs:
      start-time: ${{ steps.create-api-issue.outputs.startTime }}
      failed-reason: ${{ steps.create-api-issue.outputs.failedReason || steps.update-issue-destroying.outputs.failedReason }}
    steps:
      - id: create-api-issue
        name: Deprovision API Environment
        uses: actions/github-script@v7
        env:
          BACKEND_REPO_NAME: ${{ vars.UI_DEPLOY_REPO_NAME }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          API_MILESTONE_NUMBER: ${{ needs.validate_request_api.outputs.api-milestone-number }}
        with:
          github-token: ${{ secrets.ON_DEMAND_DEPLOY_UI_PAT }}
          script: |
            try {
              let issueBody = context.payload.issue.body;
              issueBody += "\n<br/>\n";
              issueBody += "Created because of UI Deprovision Issue "
              issueBody += `[Issue-${context.payload.issue.number}](${context.payload.issue.html_url})`;
              issueBody += "\n\n";
              const createIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: process.env.BACKEND_REPO_NAME,
                title: process.env.ORIGINAL_ISSUE_TITLE,
                body: issueBody,
                labels: context.payload.issue.labels.map(label=>label.name),
                milestone: process.env.API_MILESTONE_NUMBER
              });
              console.log("api createIssueResponse: ", createIssueResponse);
              core.setOutput("startTime", new Date().toISOString());
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during API issue creation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: update-issue-destroying
        name: Update Issue - Destroying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.milestone-branch-name }}
          DESTROY_START_TIME: ${{ steps.create-api-issue.outputs.startTime }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const commentBody = [
                "## UI Destroy Started",
                "<br/>", 
                "", "### Start Time: ", "",
                "  " + toTime(process.env.DESTROY_START_TIME), 
              ];
              
              if(process.env.MILESTONE_BRANCH_NAME) {
                commentBody.push("", "### Milestone Branch: ", "");
                commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);
              }
              commentBody.push("", "### API Issue: ", "");
              const apiIssueDetails = ${{ steps.create-api-issue.outputs.details || '{}' }};
              if(apiIssueDetails?.number) {
                const apiIssueWithLink = "[API Issue-" + apiIssueDetails.number + "](" + apiIssueDetails.html_url + ")";
                commentBody.push("The " + apiIssueWithLink + ", for API destroy is created.", "");
              }
              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }
              
              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the destroy to complete. This issue will be updated when completed.");
              commentBody.push("<br/>", "<br/>",  "");
              
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy_complete:
    name: Handle Destroy Completion
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_stack
      - destroy
    environment:
      name: ${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.wait-for-destroy.outputs.failedReason || steps.update-issue-destroy-complete.outputs.failedReason }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: Setup Node Latest
        # https://github.com/actions/setup-node
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - run: |
          npm install @aws-sdk/client-cloudformation
      - id: wait-for-destroy
        name: Wait for Destroy to Complete
        uses: actions/github-script@v7
        env:
          ENVID: ${{ vars.AWS_ENVID }}
          INITIAL_UI_STACK_STATUS: ${{ needs.validate_stack.outputs.ui-stack-status }}
        with:
          script: |
            try {
              const { CloudFormationClient, DescribeStacksCommand } = require("@aws-sdk/client-cloudformation");
              const ONE_SECOND = 1000;
              const ONE_MINUTE = ONE_SECOND * 60;
              const sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
              // Initialize CloudFormation client
              // https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/cloudformation/command/DescribeStacksCommand/
              const cloudFormationClient = new CloudFormationClient();
              const describeStack = async (stackName) => {
                try {
                  const command = new DescribeStacksCommand({ StackName: stackName });
                  const response = await cloudFormationClient.send(command);
                  console.log("method describeStack, response:", response);
                  return response.Stacks[0];
                } catch(e) {
                  console.error("method describeStack, got an error: ", e);
                }
                return null;
              };
              let stackName = `prsfin-${process.env.ENVID}-ui-deploy-stack`;
              let isStackStatusChanged = false;
              const stackSuccessRegex = new RegExp("DELETE_COMPLETE$");
              const stackFailRegex = new RegExp("DELETE_FAILED|ROLLBACK*");

              const sleepDuration = ONE_MINUTE;
              const totalWaitDuration = 30 * ONE_MINUTE;
              let waitedDuration = 0;
              const maxWaitForStatusUnchange = sleepDuration * 10;
              let isDeleted = false;
              while(waitedDuration < totalWaitDuration) {
                console.log("Destroy is in progress.", `Waiting for ${sleepDuration/ONE_SECOND} seconds ~ ${sleepDuration/ONE_MINUTE} minutes.`);
                console.log(`waited ${waitedDuration/ONE_MINUTE} minutes for destroy complete out of allowed ${totalWaitDuration/ONE_MINUTE} minutes`);
                await sleep(sleepDuration);
                waitedDuration += sleepDuration;
                const describeStackResponse = await describeStack(stackName);
                if(!describeStackResponse) {
                  // since no response, probably deleted already
                  isDeleted=true;
                  break;
                }
                // check status
                if(stackSuccessRegex.test(describeStackResponse.StackStatus)) {
                  console.log("UI Stack is destroyed successfully.");
                  isDeleted=true;
                  break;
                }
                stackName=describeStackResponse.StackId;
                
                if(!isStackStatusChanged && process.env.INITIAL_UI_STACK_STATUS===describeStackResponse.StackStatus) {
                  // since no response, probably still in creation not started
                  if(waitedDuration<maxWaitForStatusUnchange) {
                    continue;
                  }
                  throw new Error("Stack status hasnt been changed from initial for a while.");
                }
                isStackStatusChanged=true;
                
                if(stackFailRegex.test(describeStackResponse.StackStatus)) {
                  throw new Error(`Stack destroy failed. found undesired Status [${describeStackResponse.StackStatus}] with reason, ${describeStackResponse.StackStatusReason}. Please check stack events for more details.`);
                }
              }

              if(!isDeleted) {
                throw new Error(`Stack destroy is taking longer time than expected(${totalWaitDuration/ONE_MINUTE} minutes). Please check the status manually.`);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error deployment wait step, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: update-issue-destroy-complete
        name: Update Issue - Destroy Complete
        uses: actions/github-script@v7
        env:
          DESTROY_START_TIME: ${{ needs.destroy.outputs.start-time }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
        with:
          script: |
            try {
              const destroyEndTime = new Date();
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const diffParts = new Date(destroyEndTime - new Date(process.env.DESTROY_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              const commentBody = [
                "## UI Destroy Completed",
                "<br/>", 
                "", "### Destroy Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DESTROY_START_TIME)} |`,
                `| **End Time** | ${toTime(destroyEndTime)} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The Destroy is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              const unlockIssueResponse2 = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: process.env.TESTPLAN_ISSUE_NUMBER
              });
              console.log("testplan issue is unlock temporarily, unlock issue response:", unlockIssueResponse2);
              const parentCommentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: process.env.TESTPLAN_ISSUE_NUMBER,
                body: commentBody.join("\n")
              });
              console.log("for testplan, commentResponse: ", parentCommentResponse);
              const lockIssueResponse2 = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: process.env.TESTPLAN_ISSUE_NUMBER
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse2);
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for deployment completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  handle_failure:
    name: Handle Request form Failure
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_stack
      - validate_request_api
      - create_tag
      - build_artifact
      - deployment
      - deployment_complete
      - destroy
      - destroy_complete
    if: failure()
    steps:
      - run: |
          echo 'Update Request: ${{ needs.run_eligible }}'
          echo 'Update Request: ${{ needs.update_request }}'
          echo 'Validate Request: ${{ needs.validate_request }}'
          echo 'Validate Request Api: ${{ needs.validate_stack }}'
          echo 'Validate Request Api: ${{ needs.validate_request_api }}'
          echo 'Create Tag: ${{ needs.create_tag }}'
          echo 'Build Artifact: ${{ needs.build_artifact }}'
          echo 'Deployment: ${{ needs.deployment }}'
          echo 'Deployment Complete: ${{ needs.deployment_complete }}'
          echo 'Destroy: ${{ needs.destroy }}'
          echo 'Destroy: ${{ needs.destroy_complete }}'
      - if: needs.run_eligible.result == 'failure'
        run: |
          echo "Since run eligible job failed, skipping fail handler job"
          exit 1
      - id: prepare-error
        uses: actions/github-script@v7
        env:
          VALIDATION_FAIL_REASON: ${{ needs.validate_request.outputs.failed-reason || needs.validate_request_api.outputs.failed-reason || needs.validate_stack.outputs.failed-reason }}
          IS_VALIDATION_FAILED: ${{ needs.update_request.result == 'failure' || needs.validate_request.result == 'failure' || needs.validate_request_api.result == 'failure' || needs.validate_stack.result == 'failure' }}
          REQUEST_TYPE: ${{ needs.validate_request.outputs.request-type }}
          DEPLOY_FAILED_REASON: ${{ needs.create_tag.outputs.failed-reason || needs.deployment.outputs.failed-reason || needs.deployment_complete.outputs.failed-reason }}
          IS_DEPLOY_FAILED: ${{ needs.create_tag.result == 'failure' || needs.deployment.result == 'failure' || needs.deployment_complete.result == 'failure' || needs.build_artifact.result == 'failure' }}
          DESTROY_FAILED_REASON: ${{ needs.destroy.outputs.failed-reason }}
          IS_DESTROY_FAILED: ${{ needs.destroy.result == 'failure' || needs.destroy_complete.result == 'failure' }}
        with:
          script: |
            let errorDetails= "Found unknown error. Please check the logs.";
            if(String(process.env.IS_VALIDATION_FAILED) === "true") {
              errorDetails = process.env.VALIDATION_FAIL_REASON || errorDetails;
              core.setOutput("reason", "Validation of Request form is failed.");
              core.setOutput("status", "Denied");
            } else if(String(process.env.IS_DEPLOY_FAILED) === "true") {
              errorDetails = process.env.DEPLOY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Deployment of UI app is failed.");
              core.setOutput("status", "Failed");
            } else if(String(process.env.IS_DESTROY_FAILED) === "true") {
              errorDetails = process.env.DESTROY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Destroy of UI app is failed.");
              core.setOutput("status", "Failed");
            } else {
              throw new Error("could not find any fail job");
            }
            core.setOutput("details", errorDetails);
      - name: Add Failed Reason as Comment
        uses: actions/github-script@v7
        env:
          FAIL_REASON: ${{ steps.prepare-error.outputs.reason }}
          ERROR_DETAILS: ${{ steps.prepare-error.outputs.details }}
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
        with:
          script: |
            const unlockIssueResponse = await github.rest.issues.unlock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
            const commentBody = [
                    "## Request " + process.env.FAIL_STATUS, 
                    "<br/>", "",
                    "### Reason:",
                    "  " + process.env.FAIL_REASON,
                    "", "",
                    "**Error:**  " + process.env.ERROR_DETAILS, 
                    "<br/>",  "",
                    "> [!NOTE]",
                    "> **Needs Action:**   Please raise a `new request form` with correct details. This request issue will be `closed`.",
                    "<br/>", "<br/>",  "",
                  ];
            const workflowTitle = context.workflow +" (" + context.runId + ")";
            const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
            commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

            console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
            const commentResponse = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody.join("\n")
            });
            console.log("commentResponse: ", commentResponse);
      - name: Close Issue
        uses: actions/github-script@v7
        env:
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            const closeUpdateResponse = await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed',
              title: "[" + process.env.FAIL_STATUS + "]" + process.env.ORIGINAL_ISSUE_TITLE,
            });
            console.log("closeUpdateResponse: ", closeUpdateResponse);
            const lockIssueResponse = await github.rest.issues.lock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue lock again, lock issue response:", lockIssueResponse);
